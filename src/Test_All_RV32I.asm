# 完整的RV32I指令集测试文件
# 测试所有RV32I基本指令的功能

.text
    # ==================== 测试U型指令 ====================
    # LUI - 加载高位立即数
    lui x1, 0x12345        # x1 = 0x12345000
    
    # AUIPC - PC相对高位立即数
    auipc x2, 0x1000       # x2 = PC + 0x1000000
    
    # ==================== 测试I型指令 - 立即数运算 ====================
    # ADDI - 立即数加法
    addi x3, x0, 10        # x3 = 0 + 10 = 10
    
    # SLTI - 立即数有符号比较
    slti x4, x3, 5         # x4 = (10 < 5) ? 1 : 0 = 0
    slti x5, x3, 15        # x5 = (10 < 15) ? 1 : 0 = 1
    
    # SLTIU - 立即数无符号比较
    sltiu x6, x3, 5        # x6 = (10 < 5) ? 1 : 0 = 0
    sltiu x7, x3, 15       # x7 = (10 < 15) ? 1 : 0 = 1
    
    # XORI - 立即数异或
    xori x8, x3, 0x0F      # x8 = 10 ^ 15 = 5
    
    # ORI - 立即数或
    ori x9, x3, 0x0F       # x9 = 10 | 15 = 15
    
    # ANDI - 立即数与
    andi x10, x3, 0x0F     # x10 = 10 & 15 = 10
    
    # 移位指令
    slli x11, x3, 2        # x11 = 10 << 2 = 40
    srli x12, x11, 1       # x12 = 40 >> 1 = 20
    srai x13, x11, 2       # x13 = 40 >> 2 = 10
    
    # ==================== 测试R型指令 - 寄存器运算 ====================
    # ADD - 加法
    add x14, x3, x3        # x14 = 10 + 10 = 20
    
    # SUB - 减法
    sub x15, x14, x3       # x15 = 20 - 10 = 10
    
    # SLT - 有符号比较
    slt x16, x3, x14       # x16 = (10 < 20) ? 1 : 0 = 1
    slt x17, x14, x3       # x17 = (20 < 10) ? 1 : 0 = 0
    
    # SLTU - 无符号比较
    sltu x18, x3, x14      # x18 = (10 < 20) ? 1 : 0 = 1
    sltu x19, x14, x3      # x19 = (20 < 10) ? 1 : 0 = 0
    
    # XOR - 异或
    xor x20, x3, x14       # x20 = 10 ^ 20 = 30
    
    # OR - 或
    or x21, x3, x14        # x21 = 10 | 20 = 30
    
    # AND - 与
    and x22, x3, x14       # x22 = 10 & 20 = 0
    
    # 移位指令
    sll x23, x3, x5        # x23 = 10 << 1 = 20
    srl x24, x11, x5       # x24 = 40 >> 1 = 20
    sra x25, x11, x5       # x25 = 40 >> 1 = 20
    
    # ==================== 测试内存访问指令 ====================
    # 存储指令
    sw x3, 0(x0)           # 存储x3到地址0
    sw x14, 4(x0)          # 存储x14到地址4
    sw x20, 8(x0)          # 存储x20到地址8
    
    # 加载指令
    lw x26, 0(x0)          # x26 = 从地址0加载
    lw x27, 4(x0)          # x27 = 从地址4加载
    lw x28, 8(x0)          # x28 = 从地址8加载
    
    # ==================== 测试分支指令 ====================
    # BEQ - 相等分支
    beq x3, x26, _test1    # 如果x3 == x26，跳转到_test1
    addi x29, x0, 1        # x29 = 1（不执行）
    _test1:
    addi x30, x0, 2        # x30 = 2
    
    # BNE - 不等分支
    bne x3, x14, _test2    # 如果x3 != x14，跳转到_test2
    addi x31, x0, 3        # x31 = 3（不执行）
    _test2:
    addi x1, x0, 4         # x1 = 4
    
    # BLT - 有符号小于分支
    blt x3, x14, _test3    # 如果10 < 20，跳转到_test3
    addi x2, x0, 5         # x2 = 5（不执行）
    _test3:
    addi x3, x0, 6         # x3 = 6
    
    # BGE - 有符号大于等于分支
    bge x14, x3, _test4    # 如果20 >= 6，跳转到_test4
    addi x4, x0, 7         # x4 = 7（不执行）
    _test4:
    addi x5, x0, 8         # x5 = 8
    
    # BLTU - 无符号小于分支
    bltu x3, x14, _test5   # 如果6 < 20，跳转到_test5
    addi x6, x0, 9         # x6 = 9（不执行）
    _test5:
    addi x7, x0, 10        # x7 = 10
    
    # BGEU - 无符号大于等于分支
    bgeu x14, x3, _test6   # 如果20 >= 6，跳转到_test6
    addi x8, x0, 11        # x8 = 11（不执行）
    _test6:
    addi x9, x0, 12        # x9 = 12
    
    # ==================== 测试跳转指令 ====================
    # JAL - 无条件跳转并链接
    jal x10, _test7        # 跳转到_test7，x10 = PC + 4
    addi x11, x0, 13       # x11 = 13（不执行）
    _test7:
    addi x12, x0, 14       # x12 = 14
    
    # JALR - 寄存器跳转并链接
    addi x13, x0, _test8   # x13 = _test8的地址
    jalr x14, x13, 0       # 跳转到x13，x14 = PC + 4
    addi x15, x0, 15       # x15 = 15（不执行）
    _test8:
    addi x16, x0, 16       # x16 = 16
    
    # ==================== 测试字节和半字访问 ====================
    # 存储字节和半字
    sb x3, 16(x0)          # 存储字节到地址16
    sh x14, 18(x0)         # 存储半字到地址18
    
    # 加载字节和半字
    lb x17, 16(x0)         # 有符号字节加载
    lbu x18, 16(x0)        # 无符号字节加载
    lh x19, 18(x0)         # 有符号半字加载
    lhu x20, 18(x0)        # 无符号半字加载
    
    # ==================== 无限循环 ====================
    _loop:
    j _loop                # 无限循环