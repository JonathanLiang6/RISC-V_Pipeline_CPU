// Test_All_RV32I.dat - 完整RV32I指令集测试的机器码文件
// 对应Test_All_RV32I.asm汇编文件

// ==================== U型指令测试 ====================
12345037    // lui x1, 0x12345        # x1 = 0x12345000
00001017    // auipc x2, 0x1000       # x2 = PC + 0x1000000

// ==================== I型指令测试 - 立即数运算 ====================
00A00193    // addi x3, x0, 10        # x3 = 0 + 10 = 10
0051A213    // slti x4, x3, 5         # x4 = (10 < 5) ? 1 : 0 = 0
00F1A293    // slti x5, x3, 15        # x5 = (10 < 15) ? 1 : 0 = 1
0051B313    // sltiu x6, x3, 5        # x6 = (10 < 5) ? 1 : 0 = 0
00F1B393    // sltiu x7, x3, 15       # x7 = (10 < 15) ? 1 : 0 = 1
00F1C413    // xori x8, x3, 0x0F      # x8 = 10 ^ 15 = 5
00F1E493    // ori x9, x3, 0x0F       # x9 = 10 | 15 = 15
00F1F513    // andi x10, x3, 0x0F     # x10 = 10 & 15 = 10

// 移位指令
00209593    // slli x11, x3, 2        # x11 = 10 << 2 = 40
0015D613    // srli x12, x11, 1       # x12 = 40 >> 1 = 20
4025D693    // srai x13, x11, 2       # x13 = 40 >> 2 = 10

// ==================== R型指令测试 - 寄存器运算 ====================
00318733    // add x14, x3, x3        # x14 = 10 + 10 = 20
40370733    // sub x15, x14, x3       # x15 = 20 - 10 = 10
00E1A833    // slt x16, x3, x14       # x16 = (10 < 20) ? 1 : 0 = 1
00E72833    // slt x17, x14, x3       # x17 = (20 < 10) ? 1 : 0 = 0
00E1B933    // sltu x18, x3, x14      # x18 = (10 < 20) ? 1 : 0 = 1
00E73933    // sltu x19, x14, x3      # x19 = (20 < 10) ? 1 : 0 = 0
00E1CA33    // xor x20, x3, x14       # x20 = 10 ^ 20 = 30
00E1EAB3    // or x21, x3, x14        # x21 = 10 | 20 = 30
00E1FB33    // and x22, x3, x14       # x22 = 10 & 20 = 0

// 移位指令
005197B3    // sll x23, x3, x5        # x23 = 10 << 1 = 20
0055DC33    // srl x24, x11, x5       # x24 = 40 >> 1 = 20
4055DCB3    // sra x25, x11, x5       # x25 = 40 >> 1 = 20

// ==================== 内存访问指令测试 ====================
// 存储指令
00302023    // sw x3, 0(x0)           # 存储x3到地址0
00E02223    // sw x14, 4(x0)          # 存储x14到地址4
01402423    // sw x20, 8(x0)          # 存储x20到地址8

// 加载指令
00002D03    // lw x26, 0(x0)          # x26 = 从地址0加载
00402D83    // lw x27, 4(x0)          # x27 = 从地址4加载
00802E03    // lw x28, 8(x0)          # x28 = 从地址8加载

// ==================== 分支指令测试 ====================
// BEQ - 相等分支
01A18663    // beq x3, x26, _test1    # 如果x3 == x26，跳转到_test1
00100E93    // addi x29, x0, 1        # x29 = 1（不执行）
00200F13    // addi x30, x0, 2        # x30 = 2 (_test1标签)

// BNE - 不等分支
00E19663    // bne x3, x14, _test2    # 如果x3 != x14，跳转到_test2
00300F93    // addi x31, x0, 3        # x31 = 3（不执行）
00400093    // addi x1, x0, 4         # x1 = 4 (_test2标签)

// BLT - 有符号小于分支
00E1C663    // blt x3, x14, _test3    # 如果10 < 20，跳转到_test3
00500113    // addi x2, x0, 5         # x2 = 5（不执行）
00600193    // addi x3, x0, 6         # x3 = 6 (_test3标签)

// BGE - 有符号大于等于分支
00675663    // bge x14, x3, _test4    # 如果20 >= 6，跳转到_test4
00700213    // addi x4, x0, 7         # x4 = 7（不执行）
00800293    // addi x5, x0, 8         # x5 = 8 (_test4标签)

// BLTU - 无符号小于分支
0061E663    // bltu x3, x14, _test5   # 如果6 < 20，跳转到_test5
00900313    // addi x6, x0, 9         # x6 = 9（不执行）
00A00393    // addi x7, x0, 10        # x7 = 10 (_test5标签)

// BGEU - 无符号大于等于分支
0067F663    // bgeu x14, x3, _test6   # 如果20 >= 6，跳转到_test6
00B00413    // addi x8, x0, 11        # x8 = 11（不执行）
00C00493    // addi x9, x0, 12        # x9 = 12 (_test6标签)

// ==================== 跳转指令测试 ====================
// JAL - 无条件跳转并链接
01000517    // jal x10, _test7        # 跳转到_test7，x10 = PC + 4
00D00593    // addi x11, x0, 13       # x11 = 13（不执行）
00E00613    // addi x12, x0, 14       # x12 = 14 (_test7标签)

// JALR - 寄存器跳转并链接
00000693    // addi x13, x0, _test8   # x13 = _test8的地址（这里需要实际地址）
00068067    // jalr x14, x13, 0       # 跳转到x13，x14 = PC + 4
00F00713    // addi x15, x0, 15       # x15 = 15（不执行）
01000793    // addi x16, x0, 16       # x16 = 16 (_test8标签)

// ==================== 字节和半字访问测试 ====================
// 存储字节和半字
00300823    // sb x3, 16(x0)          # 存储字节到地址16
00E00923    // sh x14, 18(x0)         # 存储半字到地址18

// 加载字节和半字
01000883    // lb x17, 16(x0)         # 有符号字节加载
01000903    // lbu x18, 16(x0)        # 无符号字节加载
01200983    // lh x19, 18(x0)         # 有符号半字加载
01200A03    // lhu x20, 18(x0)        # 无符号半字加载

// ==================== 无限循环 ====================
0000006F    // j _loop                # 无限循环